{
	"objects" : [
		"anova.gam",
		"bam",
		"bam.update",
		"betar",
		"concurvity",
		"cox.ph",
		"cSplineDes",
		"exclude.too.far",
		"extract.lme.cov",
		"extract.lme.cov2",
		"fix.family.link",
		"fix.family.ls",
		"fix.family.qf",
		"fix.family.rd",
		"fix.family.var",
		"fixDependence",
		"formula.gam",
		"formXtViX",
		"fs.boundary",
		"fs.test",
		"full.score",
		"gam",
		"gam.check",
		"gam.control",
		"gam.fit",
		"gam.fit3",
		"gam.outer",
		"gam.side",
		"gam.vcomp",
		"gam2derivative",
		"gam2objective",
		"gamm",
		"gamSim",
		"gaulss",
		"get.var",
		"in.out",
		"influence.gam",
		"initial.sp",
		"inSide",
		"interpret.gam",
		"jagam",
		"ldTweedie",
		"logLik.gam",
		"ls.size",
		"magic",
		"magic.post.proc",
		"model.matrix.gam",
		"mono.con",
		"mroot",
		"multinom",
		"mvn",
		"nb",
		"negbin",
		"new.name",
		"notExp",
		"notExp2",
		"notLog",
		"notLog2",
		"null.space.dimension",
		"ocat",
		"pcls",
		"pdIdnot",
		"pdTens",
		"pen.edf",
		"place.knots",
		"plot.gam",
		"polys.plot",
		"predict.bam",
		"predict.gam",
		"Predict.matrix",
		"Predict.matrix.cr.smooth",
		"Predict.matrix.cs.smooth",
		"Predict.matrix.cyclic.smooth",
		"Predict.matrix.duchon.spline",
		"Predict.matrix.gp.smooth",
		"Predict.matrix.mrf.smooth",
		"Predict.matrix.pspline.smooth",
		"Predict.matrix.random.effect",
		"Predict.matrix.sf",
		"Predict.matrix.soap.film",
		"Predict.matrix.sos.smooth",
		"Predict.matrix.sw",
		"Predict.matrix.t2.smooth",
		"Predict.matrix.tensor.smooth",
		"Predict.matrix.tprs.smooth",
		"Predict.matrix.ts.smooth",
		"Predict.matrix2",
		"PredictMat",
		"print.anova.gam",
		"print.gam",
		"print.summary.gam",
		"qq.gam",
		"residuals.gam",
		"rig",
		"rmvn",
		"Rrank",
		"rTweedie",
		"scat",
		"sim2jam",
		"slanczos",
		"smooth.construct",
		"smooth.construct.ad.smooth.spec",
		"smooth.construct.cc.smooth.spec",
		"smooth.construct.cp.smooth.spec",
		"smooth.construct.cr.smooth.spec",
		"smooth.construct.cs.smooth.spec",
		"smooth.construct.ds.smooth.spec",
		"smooth.construct.gp.smooth.spec",
		"smooth.construct.mrf.smooth.spec",
		"smooth.construct.ps.smooth.spec",
		"smooth.construct.re.smooth.spec",
		"smooth.construct.sf.smooth.spec",
		"smooth.construct.so.smooth.spec",
		"smooth.construct.sos.smooth.spec",
		"smooth.construct.sw.smooth.spec",
		"smooth.construct.t2.smooth.spec",
		"smooth.construct.tensor.smooth.spec",
		"smooth.construct.tp.smooth.spec",
		"smooth.construct.ts.smooth.spec",
		"smooth.construct2",
		"smoothCon",
		"sp.vcov",
		"spasm.construct",
		"spasm.smooth",
		"spasm.sp",
		"summary.gam",
		"t2",
		"te",
		"tensor.prod.model.matrix",
		"tensor.prod.penalties",
		"ti",
		"tw",
		"Tweedie",
		"uniquecombs",
		"vcov.gam",
		"vis.gam",
		"ziP",
		"ziplss"
	],
	"methods" : {
		"anova.gam" : "anova.gam(object, ..., dispersion = NULL, test = NULL, freq = FALSE, p.type = 0) ",
		"bam" : "bam(formula, family = gaussian(), data = list(), weights = NULL, subset = NULL, na.action = na.omit, offset = NULL, method = \"fREML\", control = list(), select = FALSE, scale = 0, gamma = 1, knots = NULL, sp = NULL, min.sp = NULL, paraPen = NULL, chunk.size = 10000, rho = 0, AR.start = NULL, discrete = FALSE, sparse = FALSE, cluster = NULL, nthreads = NA, gc.level = 1, use.chol = FALSE, samfrac = 1, drop.unused.levels = TRUE, G = NULL, fit = TRUE, ...) ",
		"bam.update" : "bam.update(b, data, chunk.size = 10000) ",
		"betar" : "betar(theta = NULL, link = \"logit\", eps = .Machine$double.eps * 100) ",
		"concurvity" : "concurvity(b, full = TRUE) ",
		"cox.ph" : "cox.ph(link = \"identity\") ",
		"cSplineDes" : "cSplineDes(x, knots, ord = 4) ",
		"exclude.too.far" : "exclude.too.far(g1, g2, d1, d2, dist) ",
		"extract.lme.cov" : "extract.lme.cov(b, data, start.level = 1) ",
		"extract.lme.cov2" : "extract.lme.cov2(b, data, start.level = 1) ",
		"fix.family.link" : "fix.family.link(fam) ",
		"fix.family.ls" : "fix.family.ls(fam) ",
		"fix.family.qf" : "fix.family.qf(fam) ",
		"fix.family.rd" : "fix.family.rd(fam) ",
		"fix.family.var" : "fix.family.var(fam) ",
		"fixDependence" : "fixDependence(X1, X2, tol = .Machine$double.eps^0.5, rank.def = 0, strict = FALSE) ",
		"formula.gam" : "formula.gam(x, ...) ",
		"formXtViX" : "formXtViX(V, X) ",
		"fs.boundary" : "fs.boundary(r0 = 0.1, r = 0.5, l = 3, n.theta = 20) ",
		"fs.test" : "fs.test(x, y, r0 = 0.1, r = 0.5, l = 3, b = 1, exclude = TRUE) ",
		"full.score" : "full.score(sp, G, family, control, gamma, ...) ",
		"gam" : "gam(formula, family = gaussian(), data = list(), weights = NULL, subset = NULL, na.action, offset = NULL, method = \"GCV.Cp\", optimizer = c(\"outer\", \"newton\"), control = list(), scale = 0, select = FALSE, knots = NULL, sp = NULL, min.sp = NULL, H = NULL, gamma = 1, fit = TRUE, paraPen = NULL, G = NULL, in.out = NULL, drop.unused.levels = TRUE, ...) ",
		"gam.check" : "gam.check(b, old.style = FALSE, type = c(\"deviance\", \"pearson\", \"response\"), k.sample = 5000, k.rep = 200, rep = 0, level = 0.9, rl.col = 2, rep.col = \"gray80\", ...) ",
		"gam.control" : "gam.control(nthreads = 1, irls.reg = 0, epsilon = 1e-07, maxit = 200, mgcv.tol = 1e-07, mgcv.half = 15, trace = FALSE, rank.tol = .Machine$double.eps^0.5, nlm = list(), optim = list(), newton = list(), outerPIsteps = 0, idLinksBases = TRUE, scalePenalty = TRUE, keepData = FALSE, scale.est = \"fletcher\") ",
		"gam.fit" : "gam.fit(G, start = NULL, etastart = NULL, mustart = NULL, family = gaussian(), control = gam.control(), gamma = 1, fixedSteps = (control$maxit +     1), ...) ",
		"gam.fit3" : "gam.fit3(x, y, sp, Eb, UrS = list(), weights = rep(1, nobs), start = NULL, etastart = NULL, mustart = NULL, offset = rep(0,     nobs), U1 = diag(ncol(x)), Mp = -1, family = gaussian(), control = gam.control(), intercept = TRUE, deriv = 2, gamma = 1, scale = 1, printWarn = TRUE, scoreType = \"REML\", null.coef = rep(0,     ncol(x)), pearson.extra = 0, dev.extra = 0, n.true = -1, Sl = NULL, ...) ",
		"gam.outer" : "gam.outer(lsp, fscale, family, control, method, optimizer, criterion, scale, gamma, G, ...) ",
		"gam.side" : "gam.side(sm, Xp, tol = .Machine$double.eps^0.5, with.pen = FALSE) ",
		"gam.vcomp" : "gam.vcomp(x, rescale = TRUE, conf.lev = 0.95) ",
		"gam2derivative" : "gam2derivative(lsp, args, ...) ",
		"gam2objective" : "gam2objective(lsp, args, ...) ",
		"gamm" : "gamm(formula, random = NULL, correlation = NULL, family = gaussian(), data = list(), weights = NULL, subset = NULL, na.action, knots = NULL, control = list(niterEM = 0, optimMethod = \"L-BFGS-B\"), niterPQL = 20, verbosePQL = TRUE, method = \"ML\", drop.unused.levels = TRUE, ...) ",
		"gamSim" : "gamSim(eg = 1, n = 400, dist = \"normal\", scale = 2, verbose = TRUE) ",
		"gaulss" : "gaulss(link = list(\"identity\", \"logb\"), b = 0.01) ",
		"get.var" : "get.var(txt, data, vecMat = TRUE) ",
		"in.out" : "in.out(bnd, x) ",
		"influence.gam" : "influence.gam(model, ...) ",
		"initial.sp" : "initial.sp(X, S, off, expensive = FALSE, XX = FALSE) ",
		"inSide" : "inSide(bnd, x, y) ",
		"interpret.gam" : "interpret.gam(gf) ",
		"jagam" : "jagam(formula, family = gaussian, data = list(), file, weights = NULL, na.action, offset = NULL, knots = NULL, sp = NULL, drop.unused.levels = TRUE, control = gam.control(), centred = TRUE, sp.prior = \"gamma\", diagonalize = FALSE) ",
		"ldTweedie" : "ldTweedie(y, mu = y, p = 1.5, phi = 1, rho = NA, theta = NA, a = 1.001, b = 1.999) ",
		"logLik.gam" : "logLik.gam(object, ...) ",
		"ls.size" : "ls.size(x) ",
		"magic" : "magic(y, X, sp, S, off, L = NULL, lsp0 = NULL, rank = NULL, H = NULL, C = NULL, w = NULL, gamma = 1, scale = 1, gcv = TRUE, ridge.parameter = NULL, control = list(tol = 1e-06, step.half = 25,     rank.tol = .Machine$double.eps^0.5), extra.rss = 0, n.score = length(y), nthreads = 1) ",
		"magic.post.proc" : "magic.post.proc(X, object, w = NULL) ",
		"model.matrix.gam" : "model.matrix.gam(object, ...) ",
		"mono.con" : "mono.con(x, up = TRUE, lower = NA, upper = NA) ",
		"mroot" : "mroot(A, rank = NULL, method = \"chol\") ",
		"multinom" : "multinom(K = 1) ",
		"mvn" : "mvn(d = 2) ",
		"nb" : "nb(theta = NULL, link = \"log\") ",
		"negbin" : "negbin(theta = stop(\"'theta' must be specified\"), link = \"log\") ",
		"new.name" : "new.name(proposed, old.names) ",
		"notExp" : "notExp(x) ",
		"notExp2" : "notExp2(x, d = .Options$mgcv.vc.logrange, b = 1/d) ",
		"notLog" : "notLog(x) ",
		"notLog2" : "notLog2(x, d = .Options$mgcv.vc.logrange, b = 1/d) ",
		"null.space.dimension" : "null.space.dimension(d, m) ",
		"ocat" : "ocat(theta = NULL, link = \"identity\", R = NULL) ",
		"pcls" : "pcls(M) ",
		"pdIdnot" : "pdIdnot(value = numeric(0), form = NULL, nam = NULL, data = sys.frame(sys.parent())) ",
		"pdTens" : "pdTens(value = numeric(0), form = NULL, nam = NULL, data = sys.frame(sys.parent())) ",
		"pen.edf" : "pen.edf(x) ",
		"place.knots" : "place.knots(x, nk) ",
		"plot.gam" : "plot.gam(x, residuals = FALSE, rug = TRUE, se = TRUE, pages = 0, select = NULL, scale = -1, n = 100, n2 = 40, pers = FALSE, theta = 30, phi = 30, jit = FALSE, xlab = NULL, ylab = NULL, main = NULL, ylim = NULL, xlim = NULL, too.far = 0.1, all.terms = FALSE, shade = FALSE, shade.col = \"gray80\", shift = 0, trans = I, seWithMean = FALSE, unconditional = FALSE, by.resids = FALSE, scheme = 0, ...) ",
		"polys.plot" : "polys.plot(pc, z = NULL, scheme = \"heat\", lab = \"\", ...) ",
		"predict.bam" : "predict.bam(object, newdata, type = \"link\", se.fit = FALSE, terms = NULL, exclude = NULL, block.size = 50000, newdata.guaranteed = FALSE, na.action = na.pass, cluster = NULL, discrete = TRUE, n.threads = 1, ...) ",
		"predict.gam" : "predict.gam(object, newdata, type = \"link\", se.fit = FALSE, terms = NULL, exclude = NULL, block.size = NULL, newdata.guaranteed = FALSE, na.action = na.pass, unconditional = FALSE, ...) ",
		"Predict.matrix" : "Predict.matrix(object, data) ",
		"Predict.matrix.cr.smooth" : "Predict.matrix.cr.smooth(object, data) ",
		"Predict.matrix.cs.smooth" : "Predict.matrix.cs.smooth(object, data) ",
		"Predict.matrix.cyclic.smooth" : "Predict.matrix.cyclic.smooth(object, data) ",
		"Predict.matrix.duchon.spline" : "Predict.matrix.duchon.spline(object, data) ",
		"Predict.matrix.gp.smooth" : "Predict.matrix.gp.smooth(object, data) ",
		"Predict.matrix.mrf.smooth" : "Predict.matrix.mrf.smooth(object, data) ",
		"Predict.matrix.pspline.smooth" : "Predict.matrix.pspline.smooth(object, data) ",
		"Predict.matrix.random.effect" : "Predict.matrix.random.effect(object, data) ",
		"Predict.matrix.sf" : "Predict.matrix.sf(object, data) ",
		"Predict.matrix.soap.film" : "Predict.matrix.soap.film(object, data) ",
		"Predict.matrix.sos.smooth" : "Predict.matrix.sos.smooth(object, data) ",
		"Predict.matrix.sw" : "Predict.matrix.sw(object, data) ",
		"Predict.matrix.t2.smooth" : "Predict.matrix.t2.smooth(object, data) ",
		"Predict.matrix.tensor.smooth" : "Predict.matrix.tensor.smooth(object, data) ",
		"Predict.matrix.tprs.smooth" : "Predict.matrix.tprs.smooth(object, data) ",
		"Predict.matrix.ts.smooth" : "Predict.matrix.ts.smooth(object, data) ",
		"Predict.matrix2" : "Predict.matrix2(object, data) ",
		"PredictMat" : "PredictMat(object, data, n = nrow(data)) ",
		"print.anova.gam" : "print.anova.gam(x, digits = max(3, getOption(\"digits\") - 3), ...) ",
		"print.gam" : "print.gam(x, ...) ",
		"print.summary.gam" : "print.summary.gam(x, digits = max(3, getOption(\"digits\") - 3), signif.stars = getOption(\"show.signif.stars\"), ...) ",
		"qq.gam" : "qq.gam(object, rep = 0, level = 0.9, s.rep = 10, type = c(\"deviance\", \"pearson\", \"response\"), pch = \".\", rl.col = 2, rep.col = \"gray80\", ...) ",
		"residuals.gam" : "residuals.gam(object, type = \"deviance\", ...) ",
		"rig" : "rig(n, mean, scale) ",
		"rmvn" : "rmvn(n, mu, V) ",
		"Rrank" : "Rrank(R, tol = .Machine$double.eps^0.9) ",
		"rTweedie" : "rTweedie(mu, p = 1.5, phi = 1) ",
		"scat" : "scat(theta = NULL, link = \"identity\") ",
		"sim2jam" : "sim2jam(sam, pregam, edf.type = 2, burnin = 0) ",
		"slanczos" : "slanczos(A, k = 10, kl = -1, tol = .Machine$double.eps^0.5, nt = 1) ",
		"smooth.construct" : "smooth.construct(object, data, knots) ",
		"smooth.construct.ad.smooth.spec" : "smooth.construct.ad.smooth.spec(object, data, knots) ",
		"smooth.construct.cc.smooth.spec" : "smooth.construct.cc.smooth.spec(object, data, knots) ",
		"smooth.construct.cp.smooth.spec" : "smooth.construct.cp.smooth.spec(object, data, knots) ",
		"smooth.construct.cr.smooth.spec" : "smooth.construct.cr.smooth.spec(object, data, knots) ",
		"smooth.construct.cs.smooth.spec" : "smooth.construct.cs.smooth.spec(object, data, knots) ",
		"smooth.construct.ds.smooth.spec" : "smooth.construct.ds.smooth.spec(object, data, knots) ",
		"smooth.construct.gp.smooth.spec" : "smooth.construct.gp.smooth.spec(object, data, knots) ",
		"smooth.construct.mrf.smooth.spec" : "smooth.construct.mrf.smooth.spec(object, data, knots) ",
		"smooth.construct.ps.smooth.spec" : "smooth.construct.ps.smooth.spec(object, data, knots) ",
		"smooth.construct.re.smooth.spec" : "smooth.construct.re.smooth.spec(object, data, knots) ",
		"smooth.construct.sf.smooth.spec" : "smooth.construct.sf.smooth.spec(object, data, knots) ",
		"smooth.construct.so.smooth.spec" : "smooth.construct.so.smooth.spec(object, data, knots) ",
		"smooth.construct.sos.smooth.spec" : "smooth.construct.sos.smooth.spec(object, data, knots) ",
		"smooth.construct.sw.smooth.spec" : "smooth.construct.sw.smooth.spec(object, data, knots) ",
		"smooth.construct.t2.smooth.spec" : "smooth.construct.t2.smooth.spec(object, data, knots) ",
		"smooth.construct.tensor.smooth.spec" : "smooth.construct.tensor.smooth.spec(object, data, knots) ",
		"smooth.construct.tp.smooth.spec" : "smooth.construct.tp.smooth.spec(object, data, knots) ",
		"smooth.construct.ts.smooth.spec" : "smooth.construct.ts.smooth.spec(object, data, knots) ",
		"smooth.construct2" : "smooth.construct2(object, data, knots) ",
		"smoothCon" : "smoothCon(object, data, knots = NULL, absorb.cons = FALSE, scale.penalty = TRUE, n = nrow(data), dataX = NULL, null.space.penalty = FALSE, sparse.cons = 0, diagonal.penalty = FALSE, apply.by = TRUE) ",
		"sp.vcov" : "sp.vcov(x) ",
		"spasm.construct" : "spasm.construct(object, data) ",
		"spasm.smooth" : "spasm.smooth(object, X, residual = FALSE, block = 0) ",
		"spasm.sp" : "spasm.sp(object, sp, w = rep(1, object$nobs), get.trH = TRUE, block = 0, centre = FALSE) ",
		"summary.gam" : "summary.gam(object, dispersion = NULL, freq = FALSE, p.type = 0, ...) ",
		"t2" : "t2(..., k = NA, bs = \"cr\", m = NA, d = NA, by = NA, xt = NULL, id = NULL, sp = NULL, full = FALSE, ord = NULL) ",
		"te" : "te(..., k = NA, bs = \"cr\", m = NA, d = NA, by = NA, fx = FALSE, mp = TRUE, np = TRUE, xt = NULL, id = NULL, sp = NULL) ",
		"tensor.prod.model.matrix" : "tensor.prod.model.matrix(X) ",
		"tensor.prod.penalties" : "tensor.prod.penalties(S) ",
		"ti" : "ti(..., k = NA, bs = \"cr\", m = NA, d = NA, by = NA, fx = FALSE, np = TRUE, xt = NULL, id = NULL, sp = NULL, mc = NULL) ",
		"tw" : "tw(theta = NULL, link = \"log\", a = 1.01, b = 1.99) ",
		"Tweedie" : "Tweedie(p = 1, link = power(0)) ",
		"uniquecombs" : "uniquecombs(x) ",
		"vcov.gam" : "vcov.gam(object, freq = FALSE, dispersion = NULL, unconditional = FALSE, ...) ",
		"vis.gam" : "vis.gam(x, view = NULL, cond = list(), n.grid = 30, too.far = 0, col = NA, color = \"heat\", contour.col = NULL, se = -1, type = \"link\", plot.type = \"persp\", zlim = NULL, nCol = 50, ...) ",
		"ziP" : "ziP(theta = NULL, link = \"identity\", b = 0) ",
		"ziplss" : "ziplss(link = list(\"identity\", \"identity\")) "
	}
}