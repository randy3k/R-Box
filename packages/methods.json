{
	"objects" : [
		"addNextMethod",
		"allGenerics",
		"allNames",
		"Arith",
		"asMethodDefinition",
		"assignClassDef",
		"assignMethodsMetaData",
		"balanceMethodsList",
		"cacheGenericsMetaData",
		"cacheMetaData",
		"cacheMethod",
		"callGeneric",
		"callNextMethod",
		"canCoerce",
		"checkAtAssignment",
		"checkSlotAssignment",
		"classesToAM",
		"classLabel",
		"classMetaName",
		"className",
		"coerce",
		"Compare",
		"completeClassDefinition",
		"completeExtends",
		"completeSubclasses",
		"Complex",
		"conformMethod",
		"defaultDumpName",
		"defaultPrototype",
		"doPrimitiveMethod",
		"dumpMethod",
		"dumpMethods",
		"elNamed",
		"empty.dump",
		"emptyMethodsList",
		"evalOnLoad",
		"evalqOnLoad",
		"evalSource",
		"existsFunction",
		"existsMethod",
		"extends",
		"finalDefaultMethod",
		"findClass",
		"findFunction",
		"findMethod",
		"findMethods",
		"findMethodSignatures",
		"findUnique",
		"formalArgs",
		"functionBody",
		"generic.skeleton",
		"getAccess",
		"getAllMethods",
		"getAllSuperClasses",
		"getClass",
		"getClassDef",
		"getClasses",
		"getClassName",
		"getClassPackage",
		"getDataPart",
		"getExtends",
		"getFunction",
		"getGeneric",
		"getGenerics",
		"getGroup",
		"getGroupMembers",
		"getLoadActions",
		"getMethod",
		"getMethods",
		"getMethodsForDispatch",
		"getMethodsMetaData",
		"getPackageName",
		"getProperties",
		"getPrototype",
		"getRefClass",
		"getSlots",
		"getSubclasses",
		"getValidity",
		"getVirtual",
		"hasArg",
		"hasLoadAction",
		"hasMethod",
		"hasMethods",
		"implicitGeneric",
		"inheritedSlotNames",
		"initFieldArgs",
		"initialize",
		"initRefFields",
		"insertClassMethods",
		"insertMethod",
		"insertSource",
		"isClass",
		"isClassDef",
		"isClassUnion",
		"isGeneric",
		"isGrammarSymbol",
		"isGroup",
		"isSealedClass",
		"isSealedMethod",
		"isVirtualClass",
		"kronecker",
		"languageEl",
		"linearizeMlist",
		"listFromMethods",
		"listFromMlist",
		"loadMethod",
		"Logic",
		"makeClassRepresentation",
		"makeExtends",
		"makeGeneric",
		"makeMethodsList",
		"makePrototypeFromClassDef",
		"makeStandardGeneric",
		"matchSignature",
		"Math",
		"mergeMethods",
		"metaNameUndo",
		"method.skeleton",
		"MethodAddCoerce",
		"methodSignatureMatrix",
		"MethodsList",
		"MethodsListSelect",
		"methodsPackageMetaName",
		"missingArg",
		"mlistMetaName",
		"multipleClasses",
		"new",
		"newBasic",
		"newClassRepresentation",
		"newEmptyObject",
		"Ops",
		"packageSlot",
		"possibleExtends",
		"prohibitGeneric",
		"promptClass",
		"promptMethods",
		"prototype",
		"Quote",
		"reconcilePropertiesAndPrototype",
		"registerImplicitGenerics",
		"rematchDefinition",
		"removeClass",
		"removeGeneric",
		"removeMethod",
		"removeMethods",
		"removeMethodsObject",
		"representation",
		"requireMethods",
		"resetClass",
		"resetGeneric",
		"sealClass",
		"selectMethod",
		"selectSuperClasses",
		"setAs",
		"setClass",
		"setClassUnion",
		"setDataPart",
		"setGeneric",
		"setGenericImplicit",
		"setGroupGeneric",
		"setIs",
		"setLoadAction",
		"setLoadActions",
		"setMethod",
		"setOldClass",
		"setPackageName",
		"setPrimitiveMethods",
		"setRefClass",
		"setReplaceMethod",
		"setValidity",
		"show",
		"showClass",
		"showDefault",
		"showExtends",
		"showMethods",
		"showMlist",
		"signature",
		"SignatureMethod",
		"sigToEnv",
		"slot",
		"slotNames",
		"substituteDirect",
		"substituteFunctionArgs",
		"Summary",
		"superClassDepth",
		"testInheritedMethods",
		"testVirtual",
		"traceOff",
		"traceOn",
		"tryNew",
		"unRematchDefinition",
		"validObject",
		"validSlotNames"
	],
	"methods" : {
		"addNextMethod" : "addNextMethod(method, f = \"<unknown>\", mlist, optional = FALSE, envir) ",
		"allGenerics" : "allGenerics(...) ",
		"allNames" : "allNames(x) ",
		"Arith" : "Arith(e1, e2) ",
		"asMethodDefinition" : "asMethodDefinition(def, signature = list(.anyClassName), sealed = FALSE, fdef = def) ",
		"assignClassDef" : "assignClassDef(Class, def, where = .GlobalEnv, force = FALSE) ",
		"assignMethodsMetaData" : "assignMethodsMetaData(f, value, fdef, where, deflt) ",
		"balanceMethodsList" : "balanceMethodsList(mlist, args, check = TRUE) ",
		"cacheGenericsMetaData" : "cacheGenericsMetaData(f, fdef, attach = TRUE, where = topenv(parent.frame()), package, methods) ",
		"cacheMetaData" : "cacheMetaData(where, attach = TRUE, searchWhere = as.environment(where), doCheck = TRUE) ",
		"cacheMethod" : "cacheMethod(f, sig, def, args = names(sig), fdef, inherited = FALSE) ",
		"callGeneric" : "callGeneric(...) ",
		"callNextMethod" : "callNextMethod(...) ",
		"canCoerce" : "canCoerce(object, Class) ",
		"checkAtAssignment" : "checkAtAssignment(cl, name, valueClass) ",
		"checkSlotAssignment" : "checkSlotAssignment(obj, name, value) ",
		"classesToAM" : "classesToAM(classes, includeSubclasses = FALSE, abbreviate = 2) ",
		"classLabel" : "classLabel(Class) ",
		"classMetaName" : "classMetaName(name) ",
		"className" : "className(class, package) ",
		"coerce" : "coerce(from, to, strict = TRUE) ",
		"Compare" : "Compare(e1, e2) ",
		"completeClassDefinition" : "completeClassDefinition(Class, ClassDef = getClassDef(Class), where, doExtends = TRUE) ",
		"completeExtends" : "completeExtends(ClassDef, class2, extensionDef, where) ",
		"completeSubclasses" : "completeSubclasses(classDef, class2, extensionDef, where, classDef2 = getClassDef(class2, where)) ",
		"Complex" : "Complex(z) ",
		"conformMethod" : "conformMethod(signature, mnames, fnames, f = \"<unspecified>\", fdef, method) ",
		"defaultDumpName" : "defaultDumpName(generic, signature) ",
		"defaultPrototype" : "defaultPrototype() ",
		"doPrimitiveMethod" : "doPrimitiveMethod(name, def, call = sys.call(sys.parent()), ev = sys.frame(sys.parent(2))) ",
		"dumpMethod" : "dumpMethod(f, signature = character(), file = defaultDumpName(f, signature), where = topenv(parent.frame()), def = getMethod(f, signature, where = where, optional = TRUE)) ",
		"dumpMethods" : "dumpMethods(f, file = \"\", signature = NULL, methods = findMethods(f, where = where), where = topenv(parent.frame())) ",
		"elNamed" : "elNamed(x, name, mustFind = FALSE) ",
		"empty.dump" : "empty.dump() ",
		"emptyMethodsList" : "emptyMethodsList(mlist, thisClass = \"ANY\", sublist = list()) ",
		"evalOnLoad" : "evalOnLoad(expr, where = topenv(parent.frame()), aname = \"\") ",
		"evalqOnLoad" : "evalqOnLoad(expr, where = topenv(parent.frame()), aname = \"\") ",
		"evalSource" : "evalSource(source, package = \"\", lock = TRUE, cache = FALSE) ",
		"existsFunction" : "existsFunction(f, generic = TRUE, where = topenv(parent.frame())) ",
		"existsMethod" : "existsMethod(f, signature = character(), where = topenv(parent.frame())) ",
		"extends" : "extends(class1, class2, maybe = TRUE, fullInfo = FALSE) ",
		"finalDefaultMethod" : "finalDefaultMethod(method) ",
		"findClass" : "findClass(Class, where = topenv(parent.frame()), unique = \"\") ",
		"findFunction" : "findFunction(f, generic = TRUE, where = topenv(parent.frame())) ",
		"findMethod" : "findMethod(f, signature, where = topenv(parent.frame())) ",
		"findMethods" : "findMethods(f, where, classes = character(), inherited = FALSE, package = \"\") ",
		"findMethodSignatures" : "findMethodSignatures(..., target = TRUE, methods = findMethods(...)) ",
		"findUnique" : "findUnique(what, message, where = topenv(parent.frame())) ",
		"formalArgs" : "formalArgs(def) ",
		"functionBody" : "functionBody(fun = sys.function(sys.parent())) ",
		"generic.skeleton" : "generic.skeleton(name, fdef, fdefault) ",
		"getAccess" : "getAccess(ClassDef) ",
		"getAllMethods" : "getAllMethods(f, fdef, where = topenv(parent.frame())) ",
		"getAllSuperClasses" : "getAllSuperClasses(ClassDef, simpleOnly = TRUE) ",
		"getClass" : "getClass(Class, .Force = FALSE, where = .classEnv(Class, topenv(parent.frame()), FALSE)) ",
		"getClassDef" : "getClassDef(Class, where = topenv(parent.frame()), package = packageSlot(Class), inherits = TRUE) ",
		"getClasses" : "getClasses(where = .externalCallerEnv(), inherits = missing(where)) ",
		"getClassName" : "getClassName(ClassDef) ",
		"getClassPackage" : "getClassPackage(ClassDef) ",
		"getDataPart" : "getDataPart(object) ",
		"getExtends" : "getExtends(ClassDef) ",
		"getFunction" : "getFunction(name, generic = TRUE, mustFind = TRUE, where = topenv(parent.frame())) ",
		"getGeneric" : "getGeneric(f, mustFind = FALSE, where, package = \"\") ",
		"getGenerics" : "getGenerics(where, searchForm = FALSE) ",
		"getGroup" : "getGroup(fdef, recursive = FALSE, where = topenv(parent.frame())) ",
		"getGroupMembers" : "getGroupMembers(group, recursive = FALSE, character = TRUE) ",
		"getLoadActions" : "getLoadActions(where = topenv(parent.frame())) ",
		"getMethod" : "getMethod(f, signature = character(), where = topenv(parent.frame()), optional = FALSE, mlist, fdef) ",
		"getMethods" : "getMethods(f, where = topenv(parent.frame()), table = FALSE) ",
		"getMethodsForDispatch" : "getMethodsForDispatch(fdef, inherited = FALSE) ",
		"getMethodsMetaData" : "getMethodsMetaData(f, where = topenv(parent.frame())) ",
		"getPackageName" : "getPackageName(where = topenv(parent.frame()), create = TRUE) ",
		"getProperties" : "getProperties(ClassDef) ",
		"getPrototype" : "getPrototype(ClassDef) ",
		"getRefClass" : "getRefClass(Class, where = topenv(parent.frame())) ",
		"getSlots" : "getSlots(x) ",
		"getSubclasses" : "getSubclasses(ClassDef) ",
		"getValidity" : "getValidity(ClassDef) ",
		"getVirtual" : "getVirtual(ClassDef) ",
		"hasArg" : "hasArg(name) ",
		"hasLoadAction" : "hasLoadAction(aname, where = topenv(parent.frame())) ",
		"hasMethod" : "hasMethod(f, signature = character(), where = .genEnv(f, topenv(parent.frame()))) ",
		"hasMethods" : "hasMethods(f, where, package = \"\") ",
		"implicitGeneric" : "implicitGeneric(name, where = topenv(parent.frame()), generic = getGeneric(name, where = where)) ",
		"inheritedSlotNames" : "inheritedSlotNames(Class, where = topenv(parent.frame())) ",
		"initFieldArgs" : "initFieldArgs(.Object, classDef, selfEnv, ...) ",
		"initialize" : "initialize(.Object, ...) ",
		"initRefFields" : "initRefFields(.Object, classDef, selfEnv, args) ",
		"insertClassMethods" : "insertClassMethods(methods, Class, value, fieldNames, returnAll) ",
		"insertMethod" : "insertMethod(mlist, signature, args, def, cacheOnly = FALSE) ",
		"insertSource" : "insertSource(source, package = \"\", functions = allPlainObjects(), methods = (if (missing(functions)) allMethodTables() else NULL), force = missing(functions) & missing(methods)) ",
		"isClass" : "isClass(Class, formal = TRUE, where = topenv(parent.frame())) ",
		"isClassDef" : "isClassDef(object) ",
		"isClassUnion" : "isClassUnion(Class) ",
		"isGeneric" : "isGeneric(f, where = topenv(parent.frame()), fdef = NULL, getName = FALSE) ",
		"isGrammarSymbol" : "isGrammarSymbol(symbol) ",
		"isGroup" : "isGroup(f, where = topenv(parent.frame()), fdef = getGeneric(f, where = where)) ",
		"isSealedClass" : "isSealedClass(Class, where = topenv(parent.frame())) ",
		"isSealedMethod" : "isSealedMethod(f, signature, fdef = getGeneric(f, FALSE, where = where), where = topenv(parent.frame())) ",
		"isVirtualClass" : "isVirtualClass(Class, where = topenv(parent.frame())) ",
		"kronecker" : "kronecker(X, Y, FUN = \"*\", make.dimnames = FALSE, ...) ",
		"languageEl" : "languageEl(object, which) ",
		"linearizeMlist" : "linearizeMlist(mlist, inherited = TRUE) ",
		"listFromMethods" : "listFromMethods(generic, where, table) ",
		"listFromMlist" : "listFromMlist(mlist, prefix = list(), sigs. = TRUE, methods. = TRUE) ",
		"loadMethod" : "loadMethod(method, fname, envir) ",
		"Logic" : "Logic(e1, e2) ",
		"makeClassRepresentation" : "makeClassRepresentation(name, slots = list(), superClasses = character(), prototype = NULL, package, validity = NULL, access = list(), version = .newExternalptr(), sealed = FALSE, virtual = NA, where) ",
		"makeExtends" : "makeExtends(Class, to, coerce = NULL, test = NULL, replace = NULL, by = character(), package, slots = getSlots(classDef1), classDef1 = getClass(Class), classDef2) ",
		"makeGeneric" : "makeGeneric(f, fdef, fdefault = fdef, group = list(), valueClass = character(), package = getPackageName(environment(fdef)), signature = NULL, genericFunction = NULL, simpleInheritanceOnly = NULL) ",
		"makeMethodsList" : "makeMethodsList(object, level = 1) ",
		"makePrototypeFromClassDef" : "makePrototypeFromClassDef(slots, ClassDef, extends, where) ",
		"makeStandardGeneric" : "makeStandardGeneric(f, fdef) ",
		"matchSignature" : "matchSignature(signature, fun, where = baseenv()) ",
		"Math" : "Math(x) ",
		"mergeMethods" : "mergeMethods(m1, m2, genericLabel = character()) ",
		"metaNameUndo" : "metaNameUndo(strings, prefix, searchForm = FALSE) ",
		"method.skeleton" : "method.skeleton(generic, signature, file, external = FALSE, where = topenv(parent.frame())) ",
		"MethodAddCoerce" : "MethodAddCoerce(method, argName, thisClass, methodClass) ",
		"methodSignatureMatrix" : "methodSignatureMatrix(object, sigSlots = c(\"target\", \"defined\")) ",
		"MethodsList" : "MethodsList(.ArgName, ...) ",
		"MethodsListSelect" : "MethodsListSelect(f, env, mlist = NULL, fEnv = if (is(fdef, \"genericFunction\")) environment(fdef) else baseenv(), finalDefault = finalDefaultMethod(mlist), evalArgs = TRUE, useInherited = TRUE, fdef = getGeneric(f, where = env), resetAllowed = TRUE) ",
		"methodsPackageMetaName" : "methodsPackageMetaName(prefix, name, package = \"\") ",
		"missingArg" : "missingArg(symbol, envir = parent.frame(), eval = FALSE) ",
		"mlistMetaName" : "mlistMetaName(name = \"\", package = \"\") ",
		"multipleClasses" : "multipleClasses(details = FALSE) ",
		"new" : "new(Class, ...) ",
		"newBasic" : "newBasic(Class, ...) ",
		"newClassRepresentation" : "newClassRepresentation(...) ",
		"newEmptyObject" : "newEmptyObject() ",
		"Ops" : "Ops(e1, e2) ",
		"packageSlot" : "packageSlot(object) ",
		"possibleExtends" : "possibleExtends(class1, class2, ClassDef1 = getClassDef(class1), ClassDef2 = getClassDef(class2, where = .classEnv(ClassDef1))) ",
		"prohibitGeneric" : "prohibitGeneric(name, where = topenv(parent.frame())) ",
		"promptClass" : "promptClass(clName, filename = NULL, type = \"class\", keywords = \"classes\", where = topenv(parent.frame()), generatorName = clName) ",
		"promptMethods" : "promptMethods(f, filename = NULL, methods) ",
		"prototype" : "prototype(...) ",
		"Quote" : "Quote(expr) ",
		"reconcilePropertiesAndPrototype" : "reconcilePropertiesAndPrototype(name, properties, prototype, superClasses, where) ",
		"registerImplicitGenerics" : "registerImplicitGenerics(what = .ImplicitGenericsTable(where), where = topenv(parent.frame())) ",
		"rematchDefinition" : "rematchDefinition(definition, generic, mnames, fnames, signature) ",
		"removeClass" : "removeClass(Class, where = topenv(parent.frame())) ",
		"removeGeneric" : "removeGeneric(f, where = topenv(parent.frame())) ",
		"removeMethod" : "removeMethod(f, signature = character(), where = topenv(parent.frame())) ",
		"removeMethods" : "removeMethods(f, where = topenv(parent.frame()), all = missing(where)) ",
		"removeMethodsObject" : "removeMethodsObject(f, where = topenv(parent.frame())) ",
		"representation" : "representation(...) ",
		"requireMethods" : "requireMethods(functions, signature, message = \"\", where = topenv(parent.frame())) ",
		"resetClass" : "resetClass(Class, classDef, where) ",
		"resetGeneric" : "resetGeneric(f, fdef = getGeneric(f, where = where), mlist = getMethodsForDispatch(fdef), where = topenv(parent.frame()), deflt = finalDefaultMethod(mlist)) ",
		"sealClass" : "sealClass(Class, where = topenv(parent.frame())) ",
		"selectMethod" : "selectMethod(f, signature, optional = FALSE, useInherited = TRUE, mlist = if (!is.null(fdef)) getMethodsForDispatch(fdef), fdef = getGeneric(f, !optional), verbose = FALSE, doCache = FALSE) ",
		"selectSuperClasses" : "selectSuperClasses(Class, dropVirtual = FALSE, namesOnly = TRUE, directOnly = TRUE, simpleOnly = directOnly, where = topenv(parent.frame())) ",
		"setAs" : "setAs(from, to, def, replace = NULL, where = topenv(parent.frame())) ",
		"setClass" : "setClass(Class, representation = list(), prototype = NULL, contains = character(), validity = NULL, access = list(), where = topenv(parent.frame()), version = .newExternalptr(), sealed = FALSE, package = getPackageName(where), S3methods = FALSE, slots) ",
		"setClassUnion" : "setClassUnion(name, members = character(), where = topenv(parent.frame())) ",
		"setDataPart" : "setDataPart(object, value, check = TRUE) ",
		"setGeneric" : "setGeneric(name, def = NULL, group = list(), valueClass = character(), where = topenv(parent.frame()), package = NULL, signature = NULL, useAsDefault = NULL, genericFunction = NULL, simpleInheritanceOnly = NULL) ",
		"setGenericImplicit" : "setGenericImplicit(name, where = topenv(parent.frame()), restore = TRUE) ",
		"setGroupGeneric" : "setGroupGeneric(name, def = NULL, group = list(), valueClass = character(), knownMembers = list(), package = getPackageName(where), where = topenv(parent.frame())) ",
		"setIs" : "setIs(class1, class2, test = NULL, coerce = NULL, replace = NULL, by = character(), where = topenv(parent.frame()), classDef = getClass(class1,     TRUE, where = where), extensionObject = NULL, doComplete = TRUE) ",
		"setLoadAction" : "setLoadAction(action, aname = \"\", where = topenv(parent.frame())) ",
		"setLoadActions" : "setLoadActions(..., .where = topenv(parent.frame())) ",
		"setMethod" : "setMethod(f, signature = character(), definition, where = topenv(parent.frame()), valueClass = NULL, sealed = FALSE) ",
		"setOldClass" : "setOldClass(Classes, prototype = NULL, where = topenv(parent.frame()), test = FALSE, S4Class) ",
		"setPackageName" : "setPackageName(pkg, env) ",
		"setPrimitiveMethods" : "setPrimitiveMethods(f, fdef, code, generic, mlist = get(\".Methods\", envir = environment(generic))) ",
		"setRefClass" : "setRefClass(Class, fields = character(), contains = character(), methods = list(), where = topenv(parent.frame()), ...) ",
		"setReplaceMethod" : "setReplaceMethod(f, ..., where = topenv(parent.frame())) ",
		"setValidity" : "setValidity(Class, method, where = topenv(parent.frame())) ",
		"show" : "show(object) ",
		"showClass" : "showClass(Class, complete = TRUE, propertiesAreCalled = \"Slots\") ",
		"showDefault" : "showDefault(object, oldMethods = TRUE) ",
		"showExtends" : "showExtends(ext, printTo = stdout()) ",
		"showMethods" : "showMethods(f = character(), where = topenv(parent.frame()), classes = NULL, includeDefs = FALSE, inherited = !includeDefs, showEmpty, printTo = stdout(), fdef = getGeneric(f, where = where)) ",
		"showMlist" : "showMlist(mlist, includeDefs = TRUE, inherited = TRUE, classes = NULL, useArgNames = TRUE, printTo = stdout()) ",
		"signature" : "signature(...) ",
		"SignatureMethod" : "SignatureMethod(names, signature, definition) ",
		"sigToEnv" : "sigToEnv(signature, generic) ",
		"slot" : "slot(object, name) ",
		"slotNames" : "slotNames(x) ",
		"substituteDirect" : "substituteDirect(object, frame = parent.frame(), cleanFunction = TRUE) ",
		"substituteFunctionArgs" : "substituteFunctionArgs(def, newArgs, args = formalArgs(def), silent = FALSE, functionName = \"a function\") ",
		"Summary" : "Summary(x, ..., na.rm = FALSE) ",
		"superClassDepth" : "superClassDepth(ClassDef, soFar = ClassDef@className, simpleOnly = TRUE) ",
		"testInheritedMethods" : "testInheritedMethods(f, signatures, test = TRUE, virtual = FALSE, groupMethods = TRUE, where = .GlobalEnv) ",
		"testVirtual" : "testVirtual(properties, extends, prototype, where) ",
		"traceOff" : "traceOff(whatL) ",
		"traceOn" : "traceOn(what, tracer = browseAll, exit = NULL) ",
		"tryNew" : "tryNew(Class, where) ",
		"unRematchDefinition" : "unRematchDefinition(definition) ",
		"validObject" : "validObject(object, test = FALSE, complete = FALSE) ",
		"validSlotNames" : "validSlotNames(names) "
	}
}